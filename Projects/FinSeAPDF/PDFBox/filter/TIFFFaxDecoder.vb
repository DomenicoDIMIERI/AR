'/*
' * Licensed to the Apache Software Foundation (ASF) under one or more
' * contributor license agreements.  See the NOTICE file distributed with
' * this work for additional information regarding copyright ownership.
' * The ASF licenses this file to You under the Apache License, Version 2.0
' * (the "License"); you may not use this file except in compliance with
' * the License.  You may obtain a copy of the License at
' *
' *      http://www.apache.org/licenses/LICENSE-2.0
' *
' * Unless required by applicable law or agreed to in writing, software
' * distributed under the License is distributed on an "AS IS" BASIS,
' * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
' * See the License for the specific language governing permissions and
' * limitations under the License.
' */

'/* $Id$ */

Namespace org.apache.pdfbox.filter

    Class TIFFFaxDecoder

        Private bitPointer, bytePointer As Integer
        Private data() As Byte
        Private w, h As Integer
        Private fillOrder As Integer

        ' Data structures needed to store changing elements for the previous
        ' and the current scanline
        Private changingElemSize As Integer = 0
        Private prevChangingElems() As Integer
        Private currChangingElems() As Integer

        ' Element at which to start search in getNextChangingElement
        Private lastChangingElement As Integer = 0

        Private compression As Integer = 2

        ' Variables set by T4Options
        Private uncompressedMode As Integer = 0
        Private fillBits As Integer = 0
        Private oneD As Integer

        'static int[] table1 = {
        '    0x00, // 0 bits are left in first byte - SHOULD NOT HAPPEN
        '    0x01, // 1 bits are left in first byte
        '    0x03, // 2 bits are left in first byte
        '    0x07, // 3 bits are left in first byte
        '    0x0f, // 4 bits are left in first byte
        '    0x1f, // 5 bits are left in first byte
        '    0x3f, // 6 bits are left in first byte
        '    0x7f, // 7 bits are left in first byte
        '    0xff  // 8 bits are left in first byte
        '};
        Shared ReadOnly table1() As Integer = {&H0, &H1, &H3, &H7, &HF, &H1F, &H3F, &H7F, &HFF}

        'static int[] table2 = {
        '    0x00, // 0
        '    0x80, // 1
        '    0xc0, // 2
        '    0xe0, // 3
        '    0xf0, // 4
        '    0xf8, // 5
        '    0xfc, // 6
        '    0xfe, // 7
        '    0xff  // 8
        '};
        Shared ReadOnly table2() As Integer = {&H0, &H80, &HC0, &HE0, &HF0, &HF8, &HFC, &HFE, &HFF}

        ' Table to be used when fillOrder = 2, for flipping bytes.
        Shared ReadOnly flipTable() As Integer = { _
             0, -128, 64, -64, 32, -96, 96, -32, _
            16, -112, 80, -48, 48, -80, 112, -16, _
             8, -120, 72, -56, 40, -88, 104, -24, _
            24, -104, 88, -40, 56, -72, 120, -8, _
             4, -124, 68, -60, 36, -92, 100, -28, _
            20, -108, 84, -44, 52, -76, 116, -12, _
            12, -116, 76, -52, 44, -84, 108, -20, _
            28, -100, 92, -36, 60, -68, 124, -4, _
             2, -126, 66, -62, 34, -94, 98, -30, _
            18, -110, 82, -46, 50, -78, 114, -14, _
            10, -118, 74, -54, 42, -86, 106, -22, _
            26, -102, 90, -38, 58, -70, 122, -6, _
             6, -122, 70, -58, 38, -90, 102, -26, _
            22, -106, 86, -42, 54, -74, 118, -10, _
            14, -114, 78, -50, 46, -82, 110, -18, _
            30, -98, 94, -34, 62, -66, 126, -2, _
             1, -127, 65, -63, 33, -95, 97, -31, _
            17, -111, 81, -47, 49, -79, 113, -15, _
             9, -119, 73, -55, 41, -87, 105, -23, _
            25, -103, 89, -39, 57, -71, 121, -7, _
             5, -123, 69, -59, 37, -91, 101, -27, _
            21, -107, 85, -43, 53, -75, 117, -11, _
            13, -115, 77, -51, 45, -83, 109, -19, _
            29, -99, 93, -35, 61, -67, 125, -3, _
             3, -125, 67, -61, 35, -93, 99, -29, _
            19, -109, 83, -45, 51, -77, 115, -13, _
            11, -117, 75, -53, 43, -85, 107, -21, _
            27, -101, 91, -37, 59, -69, 123, -5, _
             7, -121, 71, -57, 39, -89, 103, -25, _
            23, -105, 87, -41, 55, -73, 119, -9, _
            15, -113, 79, -49, 47, -81, 111, -17, _
            31, -97, 95, -33, 63, -65, 127, -1 _
        }

        ' The main 10 bit white runs lookup table
        'Shared ReadOnly  white () As Integer = { _
        '    // 0 - 7
        '    6430,   6400,   6400,   6400,   3225,   3225,   3225,   3225,
        '    // 8 - 15
        '    944,    944,    944,    944,    976,    976,    976,    976,
        '    // 16 - 23
        '    1456,   1456,   1456,   1456,   1488,   1488,   1488,   1488,
        '    // 24 - 31
        '    718,    718,    718,    718,    718,    718,    718,    718,
        '    // 32 - 39
        '    750,    750,    750,    750,    750,    750,    750,    750,
        '    // 40 - 47
        '    1520,   1520,   1520,   1520,   1552,   1552,   1552,   1552,
        '    // 48 - 55
        '    428,    428,    428,    428,    428,    428,    428,    428,
        '    // 56 - 63
        '    428,    428,    428,    428,    428,    428,    428,    428,
        '    // 64 - 71
        '    654,    654,    654,    654,    654,    654,    654,    654,
        '    // 72 - 79
        '    1072,   1072,   1072,   1072,   1104,   1104,   1104,   1104,
        '    // 80 - 87
        '    1136,   1136,   1136,   1136,   1168,   1168,   1168,   1168,
        '    // 88 - 95
        '    1200,   1200,   1200,   1200,   1232,   1232,   1232,   1232,
        '    // 96 - 103
        '    622,    622,    622,    622,    622,    622,    622,    622,
        '    // 104 - 111
        '    1008,   1008,   1008,   1008,   1040,   1040,   1040,   1040,
        '    // 112 - 119
        '    44,     44,     44,     44,     44,     44,     44,     44,
        '    // 120 - 127
        '    44,     44,     44,     44,     44,     44,     44,     44,
        '    // 128 - 135
        '    396,    396,    396,    396,    396,    396,    396,    396,
        '    // 136 - 143
        '    396,    396,    396,    396,    396,    396,    396,    396,
        '    // 144 - 151
        '    1712,   1712,   1712,   1712,   1744,   1744,   1744,   1744,
        '    // 152 - 159
        '    846,    846,    846,    846,    846,    846,    846,    846,
        '    // 160 - 167
        '    1264,   1264,   1264,   1264,   1296,   1296,   1296,   1296,
        '    // 168 - 175
        '    1328,   1328,   1328,   1328,   1360,   1360,   1360,   1360,
        '    // 176 - 183
        '    1392,   1392,   1392,   1392,   1424,   1424,   1424,   1424,
        '    // 184 - 191
        '    686,    686,    686,    686,    686,    686,    686,    686,
        '    // 192 - 199
        '    910,    910,    910,    910,    910,    910,    910,    910,
        '    // 200 - 207
        '    1968,   1968,   1968,   1968,   2000,   2000,   2000,   2000,
        '    // 208 - 215
        '    2032,   2032,   2032,   2032,     16,     16,     16,     16,
        '    // 216 - 223
        '    10257,  10257,  10257,  10257,  12305,  12305,  12305,  12305,
        '    // 224 - 231
        '    330,    330,    330,    330,    330,    330,    330,    330,
        '    // 232 - 239
        '    330,    330,    330,    330,    330,    330,    330,    330,
        '    // 240 - 247
        '    330,    330,    330,    330,    330,    330,    330,    330,
        '    // 248 - 255
        '    330,    330,    330,    330,    330,    330,    330,    330,
        '    // 256 - 263
        '    362,    362,    362,    362,    362,    362,    362,    362,
        '    // 264 - 271
        '    362,    362,    362,    362,    362,    362,    362,    362,
        '    // 272 - 279
        '    362,    362,    362,    362,    362,    362,    362,    362,
        '    // 280 - 287
        '    362,    362,    362,    362,    362,    362,    362,    362,
        '    // 288 - 295
        '    878,    878,    878,    878,    878,    878,    878,    878,
        '    // 296 - 303
        '    1904,   1904,   1904,   1904,   1936,   1936,   1936,   1936,
        '    // 304 - 311
        '    -18413, -18413, -16365, -16365, -14317, -14317, -10221, -10221,
        '    // 312 - 319
        '    590,    590,    590,    590,    590,    590,    590,    590,
        '    // 320 - 327
        '    782,    782,    782,    782,    782,    782,    782,    782,
        '    // 328 - 335
        '    1584,   1584,   1584,   1584,   1616,   1616,   1616,   1616,
        '    // 336 - 343
        '    1648,   1648,   1648,   1648,   1680,   1680,   1680,   1680,
        '    // 344 - 351
        '    814,    814,    814,    814,    814,    814,    814,    814,
        '    // 352 - 359
        '    1776,   1776,   1776,   1776,   1808,   1808,   1808,   1808,
        '    // 360 - 367
        '    1840,   1840,   1840,   1840,   1872,   1872,   1872,   1872,
        '    // 368 - 375
        '    6157,   6157,   6157,   6157,   6157,   6157,   6157,   6157,
        '    // 376 - 383
        '    6157,   6157,   6157,   6157,   6157,   6157,   6157,   6157,
        '    // 384 - 391
        '    -12275, -12275, -12275, -12275, -12275, -12275, -12275, -12275,
        '    // 392 - 399
        '    -12275, -12275, -12275, -12275, -12275, -12275, -12275, -12275,
        '    // 400 - 407
        '    14353,  14353,  14353,  14353,  16401,  16401,  16401,  16401,
        '    // 408 - 415
        '    22547,  22547,  24595,  24595,  20497,  20497,  20497,  20497,
        '    // 416 - 423
        '    18449,  18449,  18449,  18449,  26643,  26643,  28691,  28691,
        '    // 424 - 431
        '    30739,  30739, -32749, -32749, -30701, -30701, -28653, -28653,
        '    // 432 - 439
        '    -26605, -26605, -24557, -24557, -22509, -22509, -20461, -20461,
        '    // 440 - 447
        '    8207,   8207,   8207,   8207,   8207,   8207,   8207,   8207,
        '    // 448 - 455
        '    72,     72,     72,     72,     72,     72,     72,     72,
        '    // 456 - 463
        '    72,     72,     72,     72,     72,     72,     72,     72,
        '    // 464 - 471
        '    72,     72,     72,     72,     72,     72,     72,     72,
        '    // 472 - 479
        '    72,     72,     72,     72,     72,     72,     72,     72,
        '    // 480 - 487
        '    72,     72,     72,     72,     72,     72,     72,     72,
        '    // 488 - 495
        '    72,     72,     72,     72,     72,     72,     72,     72,
        '    // 496 - 503
        '    72,     72,     72,     72,     72,     72,     72,     72,
        '    // 504 - 511
        '    72,     72,     72,     72,     72,     72,     72,     72,
        '    // 512 - 519
        '    104,    104,    104,    104,    104,    104,    104,    104,
        '    // 520 - 527
        '    104,    104,    104,    104,    104,    104,    104,    104,
        '    // 528 - 535
        '    104,    104,    104,    104,    104,    104,    104,    104,
        '    // 536 - 543
        '    104,    104,    104,    104,    104,    104,    104,    104,
        '    // 544 - 551
        '    104,    104,    104,    104,    104,    104,    104,    104,
        '    // 552 - 559
        '    104,    104,    104,    104,    104,    104,    104,    104,
        '    // 560 - 567
        '    104,    104,    104,    104,    104,    104,    104,    104,
        '    // 568 - 575
        '    104,    104,    104,    104,    104,    104,    104,    104,
        '    // 576 - 583
        '    4107,   4107,   4107,   4107,   4107,   4107,   4107,   4107,
        '    // 584 - 591
        '    4107,   4107,   4107,   4107,   4107,   4107,   4107,   4107,
        '    // 592 - 599
        '    4107,   4107,   4107,   4107,   4107,   4107,   4107,   4107,
        '    // 600 - 607
        '    4107,   4107,   4107,   4107,   4107,   4107,   4107,   4107,
        '    // 608 - 615
        '    266,    266,    266,    266,    266,    266,    266,    266,
        '    // 616 - 623
        '    266,    266,    266,    266,    266,    266,    266,    266,
        '    // 624 - 631
        '    266,    266,    266,    266,    266,    266,    266,    266,
        '    // 632 - 639
        '    266,    266,    266,    266,    266,    266,    266,    266,
        '    // 640 - 647
        '    298,    298,    298,    298,    298,    298,    298,    298,
        '    // 648 - 655
        '    298,    298,    298,    298,    298,    298,    298,    298,
        '    // 656 - 663
        '    298,    298,    298,    298,    298,    298,    298,    298,
        '    // 664 - 671
        '    298,    298,    298,    298,    298,    298,    298,    298,
        '    // 672 - 679
        '    524,    524,    524,    524,    524,    524,    524,    524,
        '    // 680 - 687
        '    524,    524,    524,    524,    524,    524,    524,    524,
        '    // 688 - 695
        '    556,    556,    556,    556,    556,    556,    556,    556,
        '    // 696 - 703
        '    556,    556,    556,    556,    556,    556,    556,    556,
        '    // 704 - 711
        '    136,    136,    136,    136,    136,    136,    136,    136,
        '    // 712 - 719
        '    136,    136,    136,    136,    136,    136,    136,    136,
        '    // 720 - 727
        '    136,    136,    136,    136,    136,    136,    136,    136,
        '    // 728 - 735
        '    136,    136,    136,    136,    136,    136,    136,    136,
        '    // 736 - 743
        '    136,    136,    136,    136,    136,    136,    136,    136,
        '    // 744 - 751
        '    136,    136,    136,    136,    136,    136,    136,    136,
        '    // 752 - 759
        '    136,    136,    136,    136,    136,    136,    136,    136,
        '    // 760 - 767
        '    136,    136,    136,    136,    136,    136,    136,    136,
        '    // 768 - 775
        '    168,    168,    168,    168,    168,    168,    168,    168,
        '    // 776 - 783
        '    168,    168,    168,    168,    168,    168,    168,    168,
        '    // 784 - 791
        '    168,    168,    168,    168,    168,    168,    168,    168,
        '    // 792 - 799
        '    168,    168,    168,    168,    168,    168,    168,    168,
        '    // 800 - 807
        '    168,    168,    168,    168,    168,    168,    168,    168,
        '    // 808 - 815
        '    168,    168,    168,    168,    168,    168,    168,    168,
        '    // 816 - 823
        '    168,    168,    168,    168,    168,    168,    168,    168,
        '    // 824 - 831
        '    168,    168,    168,    168,    168,    168,    168,    168,
        '    // 832 - 839
        '    460,    460,    460,    460,    460,    460,    460,    460,
        '    // 840 - 847
        '    460,    460,    460,    460,    460,    460,    460,    460,
        '    // 848 - 855
        '    492,    492,    492,    492,    492,    492,    492,    492,
        '    // 856 - 863
        '    492,    492,    492,    492,    492,    492,    492,    492,
        '    // 864 - 871
        '    2059,   2059,   2059,   2059,   2059,   2059,   2059,   2059,
        '    // 872 - 879
        '    2059,   2059,   2059,   2059,   2059,   2059,   2059,   2059,
        '    // 880 - 887
        '    2059,   2059,   2059,   2059,   2059,   2059,   2059,   2059,
        '    // 888 - 895
        '    2059,   2059,   2059,   2059,   2059,   2059,   2059,   2059,
        '    // 896 - 903
        '    200,    200,    200,    200,    200,    200,    200,    200,
        '    // 904 - 911
        '    200,    200,    200,    200,    200,    200,    200,    200,
        '    // 912 - 919
        '    200,    200,    200,    200,    200,    200,    200,    200,
        '    // 920 - 927
        '    200,    200,    200,    200,    200,    200,    200,    200,
        '    // 928 - 935
        '    200,    200,    200,    200,    200,    200,    200,    200,
        '    // 936 - 943
        '    200,    200,    200,    200,    200,    200,    200,    200,
        '    // 944 - 951
        '    200,    200,    200,    200,    200,    200,    200,    200,
        '    // 952 - 959
        '    200,    200,    200,    200,    200,    200,    200,    200,
        '    // 960 - 967
        '    232,    232,    232,    232,    232,    232,    232,    232,
        '    // 968 - 975
        '    232,    232,    232,    232,    232,    232,    232,    232,
        '    // 976 - 983
        '    232,    232,    232,    232,    232,    232,    232,    232,
        '    // 984 - 991
        '    232,    232,    232,    232,    232,    232,    232,    232,
        '    // 992 - 999
        '    232,    232,    232,    232,    232,    232,    232,    232,
        '    // 1000 - 1007
        '    232,    232,    232,    232,    232,    232,    232,    232,
        '    // 1008 - 1015
        '    232,    232,    232,    232,    232,    232,    232,    232,
        '    // 1016 - 1023
        '    232,    232,    232,    232,    232,    232,    232,    232,
        '};

        ''' <summary>
        ''' The main 10 bit white runs lookup table
        ''' </summary>
        ''' <remarks></remarks>
        Shared ReadOnly white() As Integer = { _
           6430, 6400, 6400, 6400, 3225, 3225, 3225, 3225, _
           944, 944, 944, 944, 976, 976, 976, 976, _
           1456, 1456, 1456, 1456, 1488, 1488, 1488, 1488, _
           718, 718, 718, 718, 718, 718, 718, 718, _
           750, 750, 750, 750, 750, 750, 750, 750, _
           1520, 1520, 1520, 1520, 1552, 1552, 1552, 1552, _
           428, 428, 428, 428, 428, 428, 428, 428, _
           428, 428, 428, 428, 428, 428, 428, 428, _
           654, 654, 654, 654, 654, 654, 654, 654, _
           1072, 1072, 1072, 1072, 1104, 1104, 1104, 1104, _
           1136, 1136, 1136, 1136, 1168, 1168, 1168, 1168, _
           1200, 1200, 1200, 1200, 1232, 1232, 1232, 1232, _
           622, 622, 622, 622, 622, 622, 622, 622, _
           1008, 1008, 1008, 1008, 1040, 1040, 1040, 1040, _
           44, 44, 44, 44, 44, 44, 44, 44, _
           44, 44, 44, 44, 44, 44, 44, 44, _
           396, 396, 396, 396, 396, 396, 396, 396, _
           396, 396, 396, 396, 396, 396, 396, 396, _
           1712, 1712, 1712, 1712, 1744, 1744, 1744, 1744, _
           846, 846, 846, 846, 846, 846, 846, 846, _
           1264, 1264, 1264, 1264, 1296, 1296, 1296, 1296, _
           1328, 1328, 1328, 1328, 1360, 1360, 1360, 1360, _
           1392, 1392, 1392, 1392, 1424, 1424, 1424, 1424, _
           686, 686, 686, 686, 686, 686, 686, 686, _
           910, 910, 910, 910, 910, 910, 910, 910, _
           1968, 1968, 1968, 1968, 2000, 2000, 2000, 2000, _
           2032, 2032, 2032, 2032, 16, 16, 16, 16, _
           10257, 10257, 10257, 10257, 12305, 12305, 12305, 12305, _
           330, 330, 330, 330, 330, 330, 330, 330, _
           330, 330, 330, 330, 330, 330, 330, 330, _
           330, 330, 330, 330, 330, 330, 330, 330, _
           330, 330, 330, 330, 330, 330, 330, 330, _
           362, 362, 362, 362, 362, 362, 362, 362, _
           362, 362, 362, 362, 362, 362, 362, 362, _
           362, 362, 362, 362, 362, 362, 362, 362, _
           362, 362, 362, 362, 362, 362, 362, 362, _
           878, 878, 878, 878, 878, 878, 878, 878, _
           1904, 1904, 1904, 1904, 1936, 1936, 1936, 1936, _
           -18413, -18413, -16365, -16365, -14317, -14317, -10221, -10221, _
           590, 590, 590, 590, 590, 590, 590, 590, _
           782, 782, 782, 782, 782, 782, 782, 782, _
           1584, 1584, 1584, 1584, 1616, 1616, 1616, 1616, _
           1648, 1648, 1648, 1648, 1680, 1680, 1680, 1680, _
           814, 814, 814, 814, 814, 814, 814, 814, _
           1776, 1776, 1776, 1776, 1808, 1808, 1808, 1808, _
           1840, 1840, 1840, 1840, 1872, 1872, 1872, 1872, _
           6157, 6157, 6157, 6157, 6157, 6157, 6157, 6157, _
           6157, 6157, 6157, 6157, 6157, 6157, 6157, 6157, _
           -12275, -12275, -12275, -12275, -12275, -12275, -12275, -12275, _
           -12275, -12275, -12275, -12275, -12275, -12275, -12275, -12275, _
           14353, 14353, 14353, 14353, 16401, 16401, 16401, 16401, _
           22547, 22547, 24595, 24595, 20497, 20497, 20497, 20497, _
           18449, 18449, 18449, 18449, 26643, 26643, 28691, 28691, _
           30739, 30739, -32749, -32749, -30701, -30701, -28653, -28653, _
           -26605, -26605, -24557, -24557, -22509, -22509, -20461, -20461, _
           8207, 8207, 8207, 8207, 8207, 8207, 8207, 8207, _
           72, 72, 72, 72, 72, 72, 72, 72, _
           72, 72, 72, 72, 72, 72, 72, 72, _
           72, 72, 72, 72, 72, 72, 72, 72, _
           72, 72, 72, 72, 72, 72, 72, 72, _
           72, 72, 72, 72, 72, 72, 72, 72, _
           72, 72, 72, 72, 72, 72, 72, 72, _
           72, 72, 72, 72, 72, 72, 72, 72, _
           72, 72, 72, 72, 72, 72, 72, 72, _
           104, 104, 104, 104, 104, 104, 104, 104, _
           104, 104, 104, 104, 104, 104, 104, 104, _
           104, 104, 104, 104, 104, 104, 104, 104, _
           104, 104, 104, 104, 104, 104, 104, 104, _
           104, 104, 104, 104, 104, 104, 104, 104, _
           104, 104, 104, 104, 104, 104, 104, 104, _
           104, 104, 104, 104, 104, 104, 104, 104, _
           104, 104, 104, 104, 104, 104, 104, 104, _
           4107, 4107, 4107, 4107, 4107, 4107, 4107, 4107, _
           4107, 4107, 4107, 4107, 4107, 4107, 4107, 4107, _
           4107, 4107, 4107, 4107, 4107, 4107, 4107, 4107, _
           4107, 4107, 4107, 4107, 4107, 4107, 4107, 4107, _
           266, 266, 266, 266, 266, 266, 266, 266, _
           266, 266, 266, 266, 266, 266, 266, 266, _
           266, 266, 266, 266, 266, 266, 266, 266, _
           266, 266, 266, 266, 266, 266, 266, 266, _
           298, 298, 298, 298, 298, 298, 298, 298, _
           298, 298, 298, 298, 298, 298, 298, 298, _
           298, 298, 298, 298, 298, 298, 298, 298, _
           298, 298, 298, 298, 298, 298, 298, 298, _
           524, 524, 524, 524, 524, 524, 524, 524, _
           524, 524, 524, 524, 524, 524, 524, 524, _
           556, 556, 556, 556, 556, 556, 556, 556, _
           556, 556, 556, 556, 556, 556, 556, 556, _
           136, 136, 136, 136, 136, 136, 136, 136, _
           136, 136, 136, 136, 136, 136, 136, 136, _
           136, 136, 136, 136, 136, 136, 136, 136, _
           136, 136, 136, 136, 136, 136, 136, 136, _
           136, 136, 136, 136, 136, 136, 136, 136, _
           136, 136, 136, 136, 136, 136, 136, 136, _
           136, 136, 136, 136, 136, 136, 136, 136, _
           136, 136, 136, 136, 136, 136, 136, 136, _
           168, 168, 168, 168, 168, 168, 168, 168, _
           168, 168, 168, 168, 168, 168, 168, 168, _
           168, 168, 168, 168, 168, 168, 168, 168, _
           168, 168, 168, 168, 168, 168, 168, 168, _
           168, 168, 168, 168, 168, 168, 168, 168, _
           168, 168, 168, 168, 168, 168, 168, 168, _
           168, 168, 168, 168, 168, 168, 168, 168, _
           168, 168, 168, 168, 168, 168, 168, 168, _
           460, 460, 460, 460, 460, 460, 460, 460, _
           460, 460, 460, 460, 460, 460, 460, 460, _
           492, 492, 492, 492, 492, 492, 492, 492, _
           492, 492, 492, 492, 492, 492, 492, 492, _
           2059, 2059, 2059, 2059, 2059, 2059, 2059, 2059, _
           2059, 2059, 2059, 2059, 2059, 2059, 2059, 2059, _
           2059, 2059, 2059, 2059, 2059, 2059, 2059, 2059, _
           2059, 2059, 2059, 2059, 2059, 2059, 2059, 2059, _
           200, 200, 200, 200, 200, 200, 200, 200, _
           200, 200, 200, 200, 200, 200, 200, 200, _
           200, 200, 200, 200, 200, 200, 200, 200, _
           200, 200, 200, 200, 200, 200, 200, 200, _
           200, 200, 200, 200, 200, 200, 200, 200, _
           200, 200, 200, 200, 200, 200, 200, 200, _
           200, 200, 200, 200, 200, 200, 200, 200, _
           200, 200, 200, 200, 200, 200, 200, 200, _
           232, 232, 232, 232, 232, 232, 232, 232, _
           232, 232, 232, 232, 232, 232, 232, 232, _
           232, 232, 232, 232, 232, 232, 232, 232, _
           232, 232, 232, 232, 232, 232, 232, 232, _
           232, 232, 232, 232, 232, 232, 232, 232, _
           232, 232, 232, 232, 232, 232, 232, 232, _
           232, 232, 232, 232, 232, 232, 232, 232, _
           232, 232, 232, 232, 232, 232, 232, 232 _
       }

        ''' <summary>
        ''' Additional make up codes for both White and Black runs
        ''' </summary>
        ''' <remarks></remarks>
        Shared ReadOnly additionalMakeup() As Integer = { _
            28679, 28679, 31752, 32777, _
            33801, 34825, 35849, 36873, _
            29703, 29703, 30727, 30727, _
            37897, 38921, 39945, 40969 _
        }

        '// Initial black run look up table, uses the first 4 bits of a code
        '  static short[] initBlack = {
        '      // 0 - 7
        '      3226,  6412,    200,    168,    38,     38,    134,    134,
        '      // 8 - 15
        '      100,    100,    100,    100,    68,     68,     68,     68
        '  };

        ''' <summary>
        ''' Initial black run look up table, uses the first 4 bits of a code
        ''' </summary>
        ''' <remarks></remarks>
        Shared ReadOnly initBlack() As Integer = {
            3226, 6412, 200, 168, 38, 38, 134, 134, _
            100, 100, 100, 100, 68, 68, 68, 68 _
        }

        Shared ReadOnly twoBitBlack() As Integer = {292, 260, 226, 226} '   // 0 - 3

        '// Main black run table, using the last 9 bits of possible 13 bit code
        'static short[] black = {
        '    // 0 - 7
        '    62,     62,     30,     30,     0,      0,      0,      0,
        '    // 8 - 15
        '    0,      0,      0,      0,      0,      0,      0,      0,
        '    // 16 - 23
        '    0,      0,      0,      0,      0,      0,      0,      0,
        '    // 24 - 31
        '    0,      0,      0,      0,      0,      0,      0,      0,
        '    // 32 - 39
        '    3225,   3225,   3225,   3225,   3225,   3225,   3225,   3225,
        '    // 40 - 47
        '    3225,   3225,   3225,   3225,   3225,   3225,   3225,   3225,
        '    // 48 - 55
        '    3225,   3225,   3225,   3225,   3225,   3225,   3225,   3225,
        '    // 56 - 63
        '    3225,   3225,   3225,   3225,   3225,   3225,   3225,   3225,
        '    // 64 - 71
        '    588,    588,    588,    588,    588,    588,    588,    588,
        '    // 72 - 79
        '    1680,   1680,  20499,  22547,  24595,  26643,   1776,   1776,
        '    // 80 - 87
        '    1808,   1808, -24557, -22509, -20461, -18413,   1904,   1904,
        '    // 88 - 95
        '    1936,   1936, -16365, -14317,    782,    782,    782,    782,
        '    // 96 - 103
        '    814,    814,    814,    814, -12269, -10221,  10257,  10257,
        '    // 104 - 111
        '    12305,  12305,  14353,  14353,  16403,  18451,   1712,   1712,
        '    // 112 - 119
        '    1744,   1744,  28691,  30739, -32749, -30701, -28653, -26605,
        '    // 120 - 127
        '    2061,   2061,   2061,   2061,   2061,   2061,   2061,   2061,
        '    // 128 - 135
        '    424,    424,    424,    424,    424,    424,    424,    424,
        '    // 136 - 143
        '    424,    424,    424,    424,    424,    424,    424,    424,
        '    // 144 - 151
        '    424,    424,    424,    424,    424,    424,    424,    424,
        '    // 152 - 159
        '    424,    424,    424,    424,    424,    424,    424,    424,
        '    // 160 - 167
        '    750,    750,    750,    750,   1616,   1616,   1648,   1648,
        '    // 168 - 175
        '    1424,   1424,   1456,   1456,   1488,   1488,   1520,   1520,
        '    // 176 - 183
        '    1840,   1840,   1872,   1872,   1968,   1968,   8209,   8209,
        '    // 184 - 191
        '    524,    524,    524,    524,    524,    524,    524,    524,
        '    // 192 - 199
        '    556,    556,    556,    556,    556,    556,    556,    556,
        '    // 200 - 207
        '    1552,   1552,   1584,   1584,   2000,   2000,   2032,   2032,
        '    // 208 - 215
        '    976,    976,   1008,   1008,   1040,   1040,   1072,   1072,
        '    // 216 - 223
        '    1296,   1296,   1328,   1328,    718,    718,    718,    718,
        '    // 224 - 231
        '    456,    456,    456,    456,    456,    456,    456,    456,
        '    // 232 - 239
        '    456,    456,    456,    456,    456,    456,    456,    456,
        '    // 240 - 247
        '    456,    456,    456,    456,    456,    456,    456,    456,
        '    // 248 - 255
        '    456,    456,    456,    456,    456,    456,    456,    456,
        '    // 256 - 263
        '    326,    326,    326,    326,    326,    326,    326,    326,
        '    // 264 - 271
        '    326,    326,    326,    326,    326,    326,    326,    326,
        '    // 272 - 279
        '    326,    326,    326,    326,    326,    326,    326,    326,
        '    // 280 - 287
        '    326,    326,    326,    326,    326,    326,    326,    326,
        '    // 288 - 295
        '    326,    326,    326,    326,    326,    326,    326,    326,
        '    // 296 - 303
        '    326,    326,    326,    326,    326,    326,    326,    326,
        '    // 304 - 311
        '    326,    326,    326,    326,    326,    326,    326,    326,
        '    // 312 - 319
        '    326,    326,    326,    326,    326,    326,    326,    326,
        '    // 320 - 327
        '    358,    358,    358,    358,    358,    358,    358,    358,
        '    // 328 - 335
        '    358,    358,    358,    358,    358,    358,    358,    358,
        '    // 336 - 343
        '    358,    358,    358,    358,    358,    358,    358,    358,
        '    // 344 - 351
        '    358,    358,    358,    358,    358,    358,    358,    358,
        '    // 352 - 359
        '    358,    358,    358,    358,    358,    358,    358,    358,
        '    // 360 - 367
        '    358,    358,    358,    358,    358,    358,    358,    358,
        '    // 368 - 375
        '    358,    358,    358,    358,    358,    358,    358,    358,
        '    // 376 - 383
        '    358,    358,    358,    358,    358,    358,    358,    358,
        '    // 384 - 391
        '    490,    490,    490,    490,    490,    490,    490,    490,
        '    // 392 - 399
        '    490,    490,    490,    490,    490,    490,    490,    490,
        '    // 400 - 407
        '    4113,   4113,   6161,   6161,    848,    848,    880,    880,
        '    // 408 - 415
        '    912,    912,    944,    944,    622,    622,    622,    622,
        '    // 416 - 423
        '    654,    654,    654,    654,   1104,   1104,   1136,   1136,
        '    // 424 - 431
        '    1168,   1168,   1200,   1200,   1232,   1232,   1264,   1264,
        '    // 432 - 439
        '    686,    686,    686,    686,   1360,   1360,   1392,   1392,
        '    // 440 - 447
        '    12,     12,     12,     12,     12,     12,     12,     12,
        '    // 448 - 455
        '    390,    390,    390,    390,    390,    390,    390,    390,
        '    // 456 - 463
        '    390,    390,    390,    390,    390,    390,    390,    390,
        '    // 464 - 471
        '    390,    390,    390,    390,    390,    390,    390,    390,
        '    // 472 - 479
        '    390,    390,    390,    390,    390,    390,    390,    390,
        '    // 480 - 487
        '    390,    390,    390,    390,    390,    390,    390,    390,
        '    // 488 - 495
        '    390,    390,    390,    390,    390,    390,    390,    390,
        '    // 496 - 503
        '    390,    390,    390,    390,    390,    390,    390,    390,
        '    // 504 - 511
        '    390,    390,    390,    390,    390,    390,    390,    390,
        '};

        ''' <summary>
        ''' Main black run table, using the last 9 bits of possible 13 bit code
        ''' </summary>
        ''' <remarks></remarks>
        Shared ReadOnly black() As Integer = { _
            62, 62, 30, 30, 0, 0, 0, 0, _
            0, 0, 0, 0, 0, 0, 0, 0, _
            0, 0, 0, 0, 0, 0, 0, 0, _
            0, 0, 0, 0, 0, 0, 0, 0, _
            3225, 3225, 3225, 3225, 3225, 3225, 3225, 3225, _
            3225, 3225, 3225, 3225, 3225, 3225, 3225, 3225, _
            3225, 3225, 3225, 3225, 3225, 3225, 3225, 3225, _
            3225, 3225, 3225, 3225, 3225, 3225, 3225, 3225, _
            588, 588, 588, 588, 588, 588, 588, 588, _
            1680, 1680, 20499, 22547, 24595, 26643, 1776, 1776, _
            1808, 1808, -24557, -22509, -20461, -18413, 1904, 1904, _
            1936, 1936, -16365, -14317, 782, 782, 782, 782, _
            814, 814, 814, 814, -12269, -10221, 10257, 10257, _
            12305, 12305, 14353, 14353, 16403, 18451, 1712, 1712, _
            1744, 1744, 28691, 30739, -32749, -30701, -28653, -26605, _
            2061, 2061, 2061, 2061, 2061, 2061, 2061, 2061, _
            424, 424, 424, 424, 424, 424, 424, 424, _
            424, 424, 424, 424, 424, 424, 424, 424, _
            424, 424, 424, 424, 424, 424, 424, 424, _
            424, 424, 424, 424, 424, 424, 424, 424, _
            750, 750, 750, 750, 1616, 1616, 1648, 1648, _
            1424, 1424, 1456, 1456, 1488, 1488, 1520, 1520, _
            1840, 1840, 1872, 1872, 1968, 1968, 8209, 8209, _
            524, 524, 524, 524, 524, 524, 524, 524, _
            556, 556, 556, 556, 556, 556, 556, 556, _
            1552, 1552, 1584, 1584, 2000, 2000, 2032, 2032, _
            976, 976, 1008, 1008, 1040, 1040, 1072, 1072, _
            1296, 1296, 1328, 1328, 718, 718, 718, 718, _
            456, 456, 456, 456, 456, 456, 456, 456, _
            456, 456, 456, 456, 456, 456, 456, 456, _
            456, 456, 456, 456, 456, 456, 456, 456, _
            456, 456, 456, 456, 456, 456, 456, 456, _
            326, 326, 326, 326, 326, 326, 326, 326, _
            326, 326, 326, 326, 326, 326, 326, 326, _
            326, 326, 326, 326, 326, 326, 326, 326, _
            326, 326, 326, 326, 326, 326, 326, 326, _
            326, 326, 326, 326, 326, 326, 326, 326, _
            326, 326, 326, 326, 326, 326, 326, 326, _
            326, 326, 326, 326, 326, 326, 326, 326, _
            326, 326, 326, 326, 326, 326, 326, 326, _
            358, 358, 358, 358, 358, 358, 358, 358, _
            358, 358, 358, 358, 358, 358, 358, 358, _
            358, 358, 358, 358, 358, 358, 358, 358, _
            358, 358, 358, 358, 358, 358, 358, 358, _
            358, 358, 358, 358, 358, 358, 358, 358, _
            358, 358, 358, 358, 358, 358, 358, 358, _
            358, 358, 358, 358, 358, 358, 358, 358, _
            358, 358, 358, 358, 358, 358, 358, 358, _
            490, 490, 490, 490, 490, 490, 490, 490, _
            490, 490, 490, 490, 490, 490, 490, 490, _
            4113, 4113, 6161, 6161, 848, 848, 880, 880, _
            912, 912, 944, 944, 622, 622, 622, 622, _
            654, 654, 654, 654, 1104, 1104, 1136, 1136, _
            1168, 1168, 1200, 1200, 1232, 1232, 1264, 1264, _
            686, 686, 686, 686, 1360, 1360, 1392, 1392, _
            12, 12, 12, 12, 12, 12, 12, 12, _
            390, 390, 390, 390, 390, 390, 390, 390, _
            390, 390, 390, 390, 390, 390, 390, 390, _
            390, 390, 390, 390, 390, 390, 390, 390, _
            390, 390, 390, 390, 390, 390, 390, 390, _
            390, 390, 390, 390, 390, 390, 390, 390, _
            390, 390, 390, 390, 390, 390, 390, 390, _
            390, 390, 390, 390, 390, 390, 390, 390, _
            390, 390, 390, 390, 390, 390, 390, 390 _
        }

        Shared ReadOnly twoDCodes() As Byte = { _
            80, 88, 23, 71, 30, 30, 62, 62, _
            4, 4, 4, 4, 4, 4, 4, 4, _
            11, 11, 11, 11, 11, 11, 11, 11, _
            11, 11, 11, 11, 11, 11, 11, 11, _
            35, 35, 35, 35, 35, 35, 35, 35, _
            35, 35, 35, 35, 35, 35, 35, 35, _
            51, 51, 51, 51, 51, 51, 51, 51, _
            51, 51, 51, 51, 51, 51, 51, 51, _
            41, 41, 41, 41, 41, 41, 41, 41, _
            41, 41, 41, 41, 41, 41, 41, 41, _
            41, 41, 41, 41, 41, 41, 41, 41, _
            41, 41, 41, 41, 41, 41, 41, 41, _
            41, 41, 41, 41, 41, 41, 41, 41, _
            41, 41, 41, 41, 41, 41, 41, 41, _
            41, 41, 41, 41, 41, 41, 41, 41, _
            41, 41, 41, 41, 41, 41, 41, 41 _
        }

        '/**
        ' * @param fillOrder   The fill order of the compressed data bytes.
        ' * @param w The width of the image in pixels
        ' * @param h The height of the image in pixels
        ' */
        Public Sub New(ByVal fillOrder As Integer, ByVal w As Integer, ByVal h As Integer)
            Me.fillOrder = fillOrder
            Me.w = w
            Me.h = h

            Me.bitPointer = 0
            Me.bytePointer = 0
            ReDim Me.prevChangingElems(w - 1)
            ReDim Me.currChangingElems(w - 1)
        End Sub

        ''' <summary>
        ''' One-dimensional decoding methods
        ''' </summary>
        ''' <param name="buffer"></param>
        ''' <param name="compData"></param>
        ''' <param name="startX"></param>
        ''' <param name="height"></param>
        ''' <remarks></remarks>
        Public Sub decode1D(ByVal buffer() As Byte, ByVal compData() As Byte, ByVal startX As Integer, ByVal height As Integer)
            Me.data = compData
            Dim lineOffset As Integer = 0
            Dim scanlineStride As Integer = (w + 7) / 8
            Me.bitPointer = 0
            Me.bytePointer = 0
            For i As Integer = 0 To height - 1
                Me.decodeNextScanline(buffer, lineOffset, startX)
                lineOffset += scanlineStride
            Next
        End Sub

        Public Sub decodeNextScanline(ByVal buffer() As Byte, ByVal lineOffset As Integer, ByVal bitOffset As Integer)
            Dim bits = 0, code = 0, isT As Integer = 0
            Dim current, entry, twoBits As Integer
            Dim isWhite As Boolean = True

            ' Initialize starting of the changing elements array
            Me.changingElemSize = 0

            ' While scanline not complete
            While (bitOffset < w)
                While (isWhite)
                    ' White run
                    current = nextNBits(10)
                    entry = white(current)

                    ' Get the 3 fields from the entry
                    isT = entry And &H1
                    bits = (entry >> 1) And &HF

                    If (bits = 12) Then ' Additional Make up code
                        ' Get the next 2 bits
                        twoBits = nextLesserThan8Bits(2)
                        ' Consolidate the 2 new bits and last 2 bits into 4 bits
                        current = ((current << 2) And &HC) Or twoBits
                        entry = additionalMakeup(current)
                        bits = (entry >> 1) And &H7 ' 3 bits 0000 0111
                        code = (entry >> 4) And &HFFF ' 12 bits
                        bitOffset += code ' Skip white run
                        updatePointer(4 - bits)
                    ElseIf (bits = 0) Then ' ERROR
                        Throw New RuntimeException("Invalid code encountered.")
                    ElseIf (bits = 15) Then ' EOL
                        Throw New RuntimeException("EOL encountered in white run.")
                    Else
                        ' 11 bits - 0000 0111 1111 1111 = 0x07ff
                        code = (entry >> 5) And &H7FF
                        bitOffset += code

                        updatePointer(10 - bits)
                        If (isT = 0) Then
                            isWhite = False
                            currChangingElems(changingElemSize) = bitOffset : changingElemSize += 1
                        End If
                    End If
                End While

                ' Check whether this run completed one width, if so
                ' advance to next byte boundary for compression = 2.
                If (bitOffset = w) Then
                    If (compression = 2) Then
                        advancePointer()
                    End If
                    Exit While
                End If

                While (Not isWhite)
                    ' Black run
                    current = nextLesserThan8Bits(4)
                    entry = initBlack(current)

                    ' Get the 3 fields from the entry
                    isT = entry And &H1
                    bits = (entry >> 1) And &HF
                    code = (entry >> 5) And &H7FF

                    If (code = 100) Then
                        current = nextNBits(9)
                        entry = black(current)

                        ' Get the 3 fields from the entry
                        isT = entry And &H1
                        bits = (entry >> 1) And &HF
                        code = (entry >> 5) And &H7FF

                        If (bits = 12) Then
                            ' Additional makeup codes
                            updatePointer(5)
                            current = nextLesserThan8Bits(4)
                            entry = additionalMakeup(current)
                            bits = (entry >> 1) And &H7 ' 3 bits 0000 0111
                            code = (entry >> 4) And &HFFF ' 12 bits

                            setToBlack(buffer, lineOffset, bitOffset, code)
                            bitOffset += code

                            updatePointer(4 - bits)
                        ElseIf (bits = 15) Then
                            'EOL code
                            Throw New RuntimeException("EOL encountered in black run.")
                        Else
                            setToBlack(buffer, lineOffset, bitOffset, code)
                            bitOffset += code

                            updatePointer(9 - bits)
                            If (isT = 0) Then
                                isWhite = True
                                currChangingElems(changingElemSize) = bitOffset : changingElemSize += 1
                            End If
                        End If
                    ElseIf (code = 200) Then
                        ' Is a Terminating code
                        current = nextLesserThan8Bits(2)
                        entry = twoBitBlack(current)
                        code = (entry >> 5) And &H7FF
                        bits = (entry >> 1) And &HF

                        setToBlack(buffer, lineOffset, bitOffset, code)
                        bitOffset += code

                        updatePointer(2 - bits)
                        isWhite = True
                        currChangingElems(changingElemSize) = bitOffset : changingElemSize += 1
                    Else
                        'Is a Terminating code
                        setToBlack(buffer, lineOffset, bitOffset, code)
                        bitOffset += code

                        updatePointer(4 - bits)
                        isWhite = True
                        currChangingElems(changingElemSize) = bitOffset : changingElemSize += 1
                    End If
                End While

                ' Check whether this run completed one width
                If (bitOffset = w) Then
                    If (compression = 2) Then
                        advancePointer()
                    End If
                    Exit While
                End If
            End While

            currChangingElems(changingElemSize) = bitOffset : changingElemSize += 1
        End Sub


        ''' <summary>
        ''' Two-dimensional decoding methods
        ''' </summary>
        ''' <param name="buffer"></param>
        ''' <param name="compData"></param>
        ''' <param name="startX"></param>
        ''' <param name="height"></param>
        ''' <param name="tiffT4Options"></param>
        ''' <remarks></remarks>
        Public Sub decode2D(ByVal buffer() As Byte, ByVal compData() As Byte, ByVal startX As Integer, ByVal height As Integer, ByVal tiffT4Options As Integer)
            Me.data = compData
            compression = 3

            bitPointer = 0
            bytePointer = 0

            Dim scanlineStride As Integer = (w + 7) / 8

            Dim a0, a1, b1, b2 As Integer
            Dim b() As Integer
            ReDim b(2 - 1)
            Dim entry, code, bits As Integer
            Dim isWhite As Boolean
            Dim currIndex As Integer = 0
            Dim temp() As Integer

            ' fillBits - dealt with this in readEOL
            ' 1D/2D encoding - dealt with this in readEOL

            ' uncompressedMode - haven't dealt with this yet.


            oneD = (tiffT4Options And &H1)
            uncompressedMode = ((tiffT4Options And &H2) >> 1)
            fillBits = ((tiffT4Options And &H4) >> 2)

            ' The data must start with an EOL code
            If (readEOL() <> 1) Then
                Throw New RuntimeException("First scanline must be 1D encoded.")
            End If

            Dim lineOffset As Integer = 0
            Dim bitOffset As Integer

            ' Then the 1D encoded scanline data will occur, changing elements
            ' array gets set.
            decodeNextScanline(buffer, lineOffset, startX)
            lineOffset += scanlineStride

            For lines As Integer = 1 To height - 1
                ' Every line must begin with an EOL followed by a bit which
                ' indicates whether the following scanline is 1D or 2D encoded.
                If (readEOL() = 0) Then
                    ' 2D encoded scanline follows

                    ' Initialize previous scanlines changing elements, and
                    ' initialize current scanline's changing elements array
                    temp = prevChangingElems
                    prevChangingElems = currChangingElems
                    currChangingElems = temp
                    currIndex = 0

                    ' a0 has to be set just before the start of this scanline.
                    a0 = -1
                    isWhite = True
                    bitOffset = startX

                    lastChangingElement = 0

                    While (bitOffset < w)
                        ' Get the next changing element
                        getNextChangingElement(a0, isWhite, b)

                        b1 = b(0)
                        b2 = b(1)

                        ' Get the next seven bits
                        entry = nextLesserThan8Bits(7)

                        ' Run these through the 2DCodes table
                        entry = (twoDCodes(entry) And &HFF)

                        ' Get the code and the number of bits used up
                        code = (entry And &H78) >> 3
                        bits = entry And &H7

                        If (code = 0) Then
                            If (Not isWhite) Then
                                setToBlack(buffer, lineOffset, bitOffset, b2 - bitOffset)
                            End If
                            bitOffset = a0 = b2
                            ' Set pointer to consume the correct number of bits.
                            updatePointer(7 - bits)
                        ElseIf (code = 1) Then
                            ' Horizontal
                            updatePointer(7 - bits)

                            ' identify the next 2 codes.
                            Dim number As Integer
                            If (isWhite) Then
                                number = decodeWhiteCodeWord()
                                bitOffset += number
                                currChangingElems(currIndex) = bitOffset : currIndex += 1

                                number = decodeBlackCodeWord()
                                setToBlack(buffer, lineOffset, bitOffset, number)
                                bitOffset += number
                                currChangingElems(currIndex) = bitOffset : currIndex += 1
                            Else
                                number = decodeBlackCodeWord()
                                setToBlack(buffer, lineOffset, bitOffset, number)
                                bitOffset += number
                                currChangingElems(currIndex) = bitOffset : currIndex += 1

                                number = decodeWhiteCodeWord()
                                bitOffset += number
                                currChangingElems(currIndex) = bitOffset : currIndex += 1
                            End If

                            a0 = bitOffset
                        ElseIf (code <= 8) Then
                            ' Vertical
                            a1 = b1 + (code - 5)

                            currChangingElems(currIndex) = a1 : currIndex += 1

                            ' We write the current color till a1 - 1 pos,
                            ' since a1 is where the next color starts
                            If (Not isWhite) Then
                                setToBlack(buffer, lineOffset, bitOffset, a1 - bitOffset)
                            End If
                            bitOffset = a0 = a1
                            isWhite = Not isWhite

                            updatePointer(7 - bits)
                        Else
                            Throw New RuntimeException("Invalid code encountered while decoding 2D group 3 compressed data.")
                        End If
                    End While

                    ' Add the changing element beyond the current scanline for the
                    ' other color too
                    currChangingElems(currIndex) = bitOffset : currIndex += 1
                    changingElemSize = currIndex
                Else
                    ' 1D encoded scanline follows
                    decodeNextScanline(buffer, lineOffset, startX)
                End If

                lineOffset += scanlineStride
            Next
        End Sub

        Public Sub decodeT6(ByVal buffer() As Byte, ByVal compData() As Byte, ByVal startX As Integer, ByVal height As Integer, ByVal tiffT6Options As Integer)
            SyncLock Me
                Me.data = compData
                compression = 4

                bitPointer = 0
                bytePointer = 0

                Dim scanlineStride As Integer = (w + 7) / 8

                Dim a0, a1, b1, b2 As Integer
                Dim entry, code, bits As Integer
                Dim isWhite As Boolean
                Dim currIndex As Integer
                Dim temp() As Integer

                ' Return values from getNextChangingElement
                Dim b() As Integer
                ReDim b(2 - 1)

                ' uncompressedMode - have written some code for this, but this
                ' has not been tested due to lack of test images using this optional

                uncompressedMode = ((tiffT6Options And &H2) >> 1)

                ' Local cached reference
                Dim cce() As Integer = currChangingElems

                ' Assume invisible preceding row of all white pixels and insert
                ' both black and white changing elements beyond the end of this
                ' imaginary scanline.
                changingElemSize = 0
                cce(changingElemSize) = w : changingElemSize += 1
                cce(changingElemSize) = w : changingElemSize += 1

                Dim lineOffset As Integer = 0
                Dim bitOffset As Integer

                For lines As Integer = 0 To height - 1
                    ' a0 has to be set just before the start of the scanline.
                    a0 = -1
                    isWhite = True

                    ' Assign the changing elements of the previous scanline to
                    ' prevChangingElems and start putting this new scanline's
                    ' changing elements into the currChangingElems.
                    temp = prevChangingElems
                    prevChangingElems = currChangingElems
                    currChangingElems = temp
                    cce = currChangingElems
                    currIndex = 0

                    ' Start decoding the scanline at startX in the raster
                    bitOffset = startX

                    ' Reset search start position for getNextChangingElement
                    lastChangingElement = 0

                    ' Till one whole scanline is decoded
                    While (bitOffset < w)
                        ' Get the next changing element
                        getNextChangingElement(a0, isWhite, b)
                        b1 = b(0)
                        b2 = b(1)

                        ' Get the next seven bits
                        entry = nextLesserThan8Bits(7)
                        ' Run these through the 2DCodes table
                        entry = (twoDCodes(entry) And &HFF)

                        ' Get the code and the number of bits used up
                        code = (entry And &H78) >> 3
                        bits = entry And &H7

                        If (code = 0) Then ' Pass
                            ' We always assume WhiteIsZero format for fax.
                            If (Not isWhite) Then
                                setToBlack(buffer, lineOffset, bitOffset, b2 - bitOffset)
                            End If
                            bitOffset = a0 = b2

                            ' Set pointer to only consume the correct number of bits.
                            updatePointer(7 - bits)
                        ElseIf (code = 1) Then ' Horizontal
                            ' Set pointer to only consume the correct number of bits.
                            updatePointer(7 - bits)

                            ' identify the next 2 alternating color codes.
                            Dim number As Integer
                            If (isWhite) Then
                                ' Following are white and black runs
                                number = decodeWhiteCodeWord()
                                bitOffset += number
                                cce(currIndex) = bitOffset : currIndex += 1

                                number = decodeBlackCodeWord()
                                setToBlack(buffer, lineOffset, bitOffset, number)
                                bitOffset += number
                                cce(currIndex) = bitOffset : currIndex += 1
                            Else
                                ' First a black run and then a white run follows
                                number = decodeBlackCodeWord()
                                setToBlack(buffer, lineOffset, bitOffset, number)
                                bitOffset += number
                                cce(currIndex) = bitOffset : currIndex += 1

                                number = decodeWhiteCodeWord()
                                bitOffset += number
                                cce(currIndex) = bitOffset : currIndex += 1
                            End If

                            a0 = bitOffset
                        ElseIf (code <= 8) Then ' Vertical
                            a1 = b1 + (code - 5)
                            cce(currIndex) = a1 : currIndex += 1

                            ' We write the current color till a1 - 1 pos,
                            ' since a1 is where the next color starts
                            If (Not isWhite) Then
                                setToBlack(buffer, lineOffset, bitOffset, a1 - bitOffset)
                            End If
                            bitOffset = a0 = a1
                            isWhite = Not isWhite

                            updatePointer(7 - bits)
                        ElseIf (code = 11) Then
                            If (nextLesserThan8Bits(3) <> 7) Then
                                Throw New RuntimeException("Invalid code encountered while decoding 2D group 4 compressed data.")
                            End If

                            Dim zeros As Integer = 0
                            Dim [exit] As Boolean = False

                            While (Not [exit])
                                While (nextLesserThan8Bits(1) <> 1)
                                    zeros += 1
                                End While

                                If (zeros > 5) Then
                                    ' Exit code

                                    ' Zeros before exit code
                                    zeros = zeros - 6

                                    If (Not isWhite AndAlso (zeros > 0)) Then
                                        cce(currIndex) = bitOffset : currIndex += 1
                                    End If

                                    ' Zeros before the exit code
                                    bitOffset += zeros
                                    If (zeros > 0) Then
                                        ' Some zeros have been written
                                        isWhite = True
                                    End If

                                    ' Read in the bit which specifies the color of
                                    ' the following run
                                    If (nextLesserThan8Bits(1) = 0) Then
                                        If (Not isWhite) Then
                                            cce(currIndex) = bitOffset : currIndex += 1
                                        End If
                                        isWhite = True
                                    Else
                                        If (isWhite) Then
                                            cce(currIndex) = bitOffset : currIndex += 1
                                        End If
                                        isWhite = False
                                    End If

                                    [exit] = True
                                End If

                                If (zeros = 5) Then
                                    If (Not isWhite) Then
                                        cce(currIndex) = bitOffset : currIndex += 1
                                    End If
                                    bitOffset += zeros

                                    ' Last thing written was white
                                    isWhite = True
                                Else
                                    bitOffset += zeros

                                    cce(currIndex) = bitOffset : currIndex += 1
                                    setToBlack(buffer, lineOffset, bitOffset, 1)
                                    bitOffset += 1

                                    ' Last thing written was black
                                    isWhite = False
                                End If
                            End While
                        Else
                            Throw New RuntimeException("Invalid code encountered while decoding 2D group 4 compressed data.")
                        End If
                    End While


                    ' Add the changing element beyond the current scanline for the
                    ' other color too
                    cce(currIndex) = bitOffset : currIndex += 1

                    ' Number of changing elements in this scanline.
                    changingElemSize = currIndex

                    lineOffset += scanlineStride
                Next
            End SyncLock
        End Sub

        Private Sub setToBlack(ByVal buffer() As Byte, ByVal lineOffset As Integer, ByVal bitOffset As Integer, ByVal numBits As Integer)
            Dim bitNum As Integer = 8 * lineOffset + bitOffset
            Dim lastBit As Integer = bitNum + numBits

            Dim byteNum As Integer = bitNum >> 3

            ' Handle bits in first byte
            Dim shift As Integer = bitNum And &H7
            If (shift > 0) Then
                Dim maskVal As Integer = 1 << (7 - shift)
                Dim val As Byte = buffer(byteNum)
                While (maskVal > 0 AndAlso bitNum < lastBit)
                    val = val Or maskVal
                    maskVal >>= 1
                    bitNum += 1
                End While
                buffer(byteNum) = val
            End If

            ' Fill in 8 bits at a time
            byteNum = bitNum >> 3
            While (bitNum < lastBit - 7)
                buffer(byteNum) = 255 : byteNum += 1
                bitNum += 8
            End While

            ' Fill in remaining bits
            While (bitNum < lastBit)
                byteNum = bitNum >> 3
                buffer(byteNum) = buffer(byteNum) Or (1 << (7 - (bitNum And &H7)))
                bitNum += 1
            End While
        End Sub

        ''' <summary>
        ''' Returns run length
        ''' </summary>
        ''' <returns></returns>
        ''' <remarks></remarks>
        Private Function decodeWhiteCodeWord() As Integer
            Dim current, entry, bits, isT, twoBits As Integer
            Dim code As Integer = -1
            Dim runLength As Integer = 0
            Dim isWhite As Boolean = True

            While (isWhite)
                current = nextNBits(10)
                entry = white(current)

                ' Get the 3 fields from the entry
                isT = entry And &H1
                bits = (entry >> 1) And &HF

                If (bits = 12) Then ' Additional Make up code
                    ' Get the next 2 bits
                    twoBits = nextLesserThan8Bits(2)
                    ' Consolidate the 2 new bits and last 2 bits into 4 bits
                    current = ((current << 2) And &HC) Or twoBits
                    entry = additionalMakeup(current)
                    bits = (entry >> 1) And &H7 '     // 3 bits 0000 0111
                    code = (entry >> 4) And &HFFF '   // 12 bits
                    runLength += code
                    updatePointer(4 - bits)
                ElseIf (bits = 0) Then ' ERROR
                    Throw New RuntimeException("Invalid code encountered.")
                ElseIf (bits = 15) Then ' EOL
                    Throw New RuntimeException("EOL encountered in white run.")
                Else
                    '11 bits - 0000 0111 1111 1111 = 0x07ff
                    code = (entry >> 5) And &H7FF
                    runLength += code
                    updatePointer(10 - bits)
                    If (isT = 0) Then
                        isWhite = False
                    End If
                End If
            End While

            Return runLength
        End Function

        ''' <summary>
        ''' Returns run length
        ''' </summary>
        ''' <returns></returns>
        ''' <remarks></remarks>
        Private Function decodeBlackCodeWord() As Integer
            Dim current, entry, bits, isT, code As Integer
            Dim runLength As Integer = 0
            Dim isWhite As Boolean = False
            code = -1
            While (Not isWhite)
                current = nextLesserThan8Bits(4)
                entry = initBlack(current)

                ' Get the 3 fields from the entry
                isT = entry And &H1
                bits = (entry >> 1) And &HF
                code = (entry >> 5) And &H7FF

                If (code = 100) Then
                    current = nextNBits(9)
                    entry = black(current)

                    ' Get the 3 fields from the entry
                    isT = entry And &H1
                    bits = (entry >> 1) And &HF
                    code = (entry >> 5) And &H7FF

                    If (bits = 12) Then
                        ' Additional makeup codes
                        updatePointer(5)
                        current = nextLesserThan8Bits(4)
                        entry = additionalMakeup(current)
                        bits = (entry >> 1) And &H7 ' 3 bits 0000 0111
                        code = (entry >> 4) And &HFFF ' 12 bits
                        runLength += code

                        updatePointer(4 - bits)
                    ElseIf (bits = 15) Then
                        ' EOL code
                        Throw New RuntimeException("EOL encountered in black run.")
                    Else
                        runLength += code
                        updatePointer(9 - bits)
                        If (isT = 0) Then
                            isWhite = True
                        End If
                    End If
                ElseIf (code = 200) Then
                    ' Is a Terminating code
                    current = nextLesserThan8Bits(2)
                    entry = twoBitBlack(current)
                    code = (entry >> 5) And &H7FF
                    runLength += code
                    bits = (entry >> 1) And &HF
                    updatePointer(2 - bits)
                    isWhite = True
                Else
                    ' Is a Terminating code
                    runLength += code
                    updatePointer(4 - bits)
                    isWhite = True
                End If
            End While

            Return runLength
        End Function

        Private Function readEOL() As Integer
            If (fillBits = 0) Then
                If (nextNBits(12) <> 1) Then
                    Throw New RuntimeException("Scanline must begin with EOL.")
                End If
            ElseIf (fillBits = 1) Then

                ' First EOL code word xxxx 0000 0000 0001 will occur
                ' As many fill bits will be present as required to make
                ' the EOL code of 12 bits end on a byte boundary.

                Dim bitsLeft As Integer = 8 - bitPointer

                If (nextNBits(bitsLeft) <> 0) Then
                    Throw New RuntimeException("All fill bits preceding EOL code must be 0.")
                End If

                ' If the number of bitsLeft is less than 8, then to have a 12
                ' bit EOL sequence, two more bytes are certainly going to be
                ' required. The first of them has to be all zeros, so ensure
                ' that.
                If (bitsLeft < 4) Then
                    If (nextNBits(8) <> 0) Then
                        Throw New RuntimeException("All fill bits preceding EOL code must be 0.")
                    End If
                End If

                ' There might be a random number of fill bytes with 0s, so
                ' loop till the EOL of 0000 0001 is found, as long as all
                ' the bytes preceding it are 0's.
                Dim n As Integer
                n = nextNBits(8)
                While (n <> 1)

                    ' If not all zeros
                    If (n <> 0) Then
                        Throw New RuntimeException("All fill bits preceding EOL code must be 0.")
                    End If
                    n = nextNBits(8)
                End While
            End If

            ' If one dimensional encoding mode, then always return 1
            If (oneD = 0) Then
                Return 1
            Else
                ' Otherwise for 2D encoding mode,
                ' The next one bit signifies 1D/2D encoding of next line.
                Return nextLesserThan8Bits(1)
            End If
        End Function

        Private Sub getNextChangingElement(ByVal a0 As Integer, ByVal isWhite As Boolean, ByVal ret() As Integer)
            ' Local copies of instance variables
            Dim pce() As Integer = Me.prevChangingElems
            Dim ces As Integer = Me.changingElemSize

            ' If the previous match was at an odd element, we still
            ' have to search the preceeding element.
            ' int start = lastChangingElement & ~0x1;
            Dim start As Integer = IIf(lastChangingElement > 0, lastChangingElement - 1, 0)
            If (isWhite) Then
                start = start And Not &H1 ' Search even numbered elements
            Else
                start = start Or &H1 ' Search odd numbered elements
            End If

            Dim i As Integer = start
            For i = start To ces - 2 Step 2
                Dim temp As Integer = pce(i)
                If (temp > a0) Then
                    lastChangingElement = i
                    ret(0) = temp
                    Exit For
                End If
            Next

            If (i + 1 < ces) Then
                ret(1) = pce(i + 1)
            End If
        End Sub

        Private Function nextNBits(ByVal bitsToGet As Integer) As Integer
            Dim b, [next], next2next As Byte
            Dim l As Integer = data.Length - 1
            Dim bp As Integer = Me.bytePointer

            If (fillOrder = 1) Then
                b = data(bp)

                If (bp = l) Then
                    [next] = &H0
                    next2next = &H0
                ElseIf ((bp + 1) = l) Then
                    [next] = data(bp + 1)
                    next2next = &H0
                Else
                    [next] = data(bp + 1)
                    next2next = data(bp + 2)
                End If
            ElseIf (fillOrder = 2) Then
                b = flipTable(data(bp) And &HFF)

                If (bp = l) Then
                    [next] = &H0
                    next2next = &H0
                ElseIf ((bp + 1) = l) Then
                    [next] = flipTable(data(bp + 1) And &HFF)
                    next2next = &H0
                Else
                    [next] = flipTable(data(bp + 1) And &HFF)
                    next2next = flipTable(data(bp + 2) And &HFF)
                End If
            Else
                Throw New RuntimeException("TIFF_FILL_ORDER tag must be either 1 or 2.")
            End If

            Dim bitsLeft As Integer = 8 - bitPointer
            Dim bitsFromNextByte As Integer = bitsToGet - bitsLeft
            Dim bitsFromNext2NextByte As Integer = 0
            If (bitsFromNextByte > 8) Then
                bitsFromNext2NextByte = bitsFromNextByte - 8
                bitsFromNextByte = 8
            End If

            bytePointer += 1

            Dim i1 As Integer = (b And table1(bitsLeft)) << (bitsToGet - bitsLeft)
            Dim i2 As Integer = ([next] And table2(bitsFromNextByte)) >> (8 - bitsFromNextByte)

            Dim i3 As Integer = 0
            If (bitsFromNext2NextByte <> 0) Then
                i2 <<= bitsFromNext2NextByte
                i3 = (next2next And table2(bitsFromNext2NextByte)) >> (8 - bitsFromNext2NextByte)
                i2 = i2 Or i3
                bytePointer += 1
                bitPointer = bitsFromNext2NextByte
            Else
                If (bitsFromNextByte = 8) Then
                    bitPointer = 0
                    bytePointer += 1
                Else
                    bitPointer = bitsFromNextByte
                End If
            End If

            Dim i As Integer = i1 Or i2
            Return i
        End Function

        Private Function nextLesserThan8Bits(ByVal bitsToGet As Integer)
            Dim b, [next] As Byte
            Dim l As Integer = data.Length - 1
            Dim bp As Integer = Me.bytePointer

            If (fillOrder = 1) Then
                b = data(bp)
                If (bp = l) Then
                    [next] = &H0
                Else
                    [next] = data(bp + 1)
                End If
            ElseIf (fillOrder = 2) Then
                b = flipTable(data(bp) And &HFF)
                If (bp = l) Then
                    [next] = &H0
                Else
                    [next] = flipTable(data(bp + 1) And &HFF)
                End If
            Else
                Throw New RuntimeException("TIFF_FILL_ORDER tag must be either 1 or 2.")
            End If

            Dim bitsLeft As Integer = 8 - bitPointer
            Dim bitsFromNextByte As Integer = bitsToGet - bitsLeft

            Dim shift As Integer = bitsLeft - bitsToGet
            Dim i1, i2 As Integer
            If (shift >= 0) Then
                i1 = (b And table1(bitsLeft)) >> shift
                bitPointer += bitsToGet
                If (bitPointer = 8) Then
                    bitPointer = 0
                    bytePointer += 1
                End If
            Else
                i1 = (b And table1(bitsLeft)) << (-shift)
                i2 = ([next] And table2(bitsFromNextByte)) >> (8 - bitsFromNextByte)

                i1 = i1 Or i2
                bytePointer += 1
                bitPointer = bitsFromNextByte
            End If

            Return i1
        End Function

        ''' <summary>
        ''' Move pointer backwards by given amount of bits
        ''' </summary>
        ''' <param name="bitsToMoveBack"></param>
        ''' <remarks></remarks>
        Private Sub updatePointer(ByVal bitsToMoveBack As Integer)
            Dim i As Integer = bitPointer - bitsToMoveBack

            If (i < 0) Then
                bytePointer -= 1
                bitPointer = 8 + i
            Else
                bitPointer = i
            End If
        End Sub

        ''' <summary>
        ''' Move to the next byte boundary
        ''' </summary>
        ''' <returns></returns>
        ''' <remarks></remarks>
        Private Function advancePointer() As Boolean
            If (bitPointer <> 0) Then
                bytePointer += 1
                bitPointer = 0
            End If
            Return True
        End Function

    End Class

End Namespace

